// controllers/orderController.js
const moment = require('moment');
const querystring = require('qs');
const crypto = require('crypto');
const Order = require("../models/Order");
const Voucher = require("../models/voucher");
const Cart = require("../models/Cart");
const asyncHandler = require("express-async-handler");
const User = require("../models/User");
const admin = require('../config/firebase-admin'); // thay ƒë√∫ng ƒë∆∞·ªùng d·∫´n t·ªõi file firebase.js

// import moment from 'moment'
// import querystring from 'qs'
// import crypto, { verify } from 'crypto'




const createOrder = asyncHandler(async (req, res) => {
  try {
    const {
      customerName,
      phone,
      deliveryAddress,
      paymentMethod,
      orderTotal,
      voucherCode
    } = req.body;

    // Validate input
    if (!customerName || !phone || !deliveryAddress || !paymentMethod) {
      return res.status(400).json({
        success: false,
        message: "Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß th√¥ng tin"
      });
    }

    // Ki·ªÉm tra ph∆∞∆°ng th·ª©c thanh to√°n
    if (!["cash", "cod"].includes(paymentMethod)) {

      return res.status(400).json({
        success: false,
        message: "Ph∆∞∆°ng th·ª©c thanh to√°n kh√¥ng h·ª£p l·ªá"
      });
    }

    // L·∫•y gi·ªè h√†ng
    const cart = await Cart.findOne({ userId: req.user._id });
    if (!cart || cart.items.length === 0) {

      return res.status(400).json({
        success: false,
        message: "Gi·ªè h√†ng tr·ªëng"
      });
    }


    // T·∫°o items t·ª´ gi·ªè h√†ng
    const orderItems = cart.items.map(item => ({
      name: item.name,
      price: item.price,
      image: item.image,
      quantity: item.quantity,
      category: item.category
    }));


    // T·∫°o ƒë∆°n h√†ng
    const [order] = await Order.create([{
      userId: req.user._id,
      customerName,
      phone,
      deliveryAddress,
      paymentMethod,
      items: orderItems,
      // total: Number((orderTotal - discount).toFixed(2)),
      total: Number(orderTotal),
      voucher: voucherCode ? voucherCode.toUpperCase() : null,
      // voucher: voucherData
    }],);

    // X√≥a gi·ªè h√†ng

    cart.items = [];
    await cart.save();
    const recipients = await User.find({
      role: { $in: ["admin", "staff"] },
      fcmToken: { $exists: true, $ne: null }
    });
    if (recipients.length > 0) {
      const tokens = recipients.map(user => user.fcmToken);

      const message = {
        notification: {
          title: "ƒê∆°n h√†ng m·ªõi",
          body: `ƒê∆°n h√†ng #${order._id} v·ª´a ƒë∆∞·ª£c t·∫°o. Vui l√≤ng ki·ªÉm tra!`
        },
        tokens: tokens, // g·ª≠i nhi·ªÅu token
        data: {
          orderId: order._id.toString(),
          click_action: "FLUTTER_NOTIFICATION_CLICK",
        }
      };

      const response = await admin.messaging().sendEachForMulticast({ tokens, ...message });
      console.log(`üü¢ G·ª≠i FCM th√†nh c√¥ng: ${response.successCount}, th·∫•t b·∫°i: ${response.failureCount}`);
    }



    res.status(201).json({
      success: true,
      data: order
    });

  } catch (error) {

    res.status(500).json({
      success: false,
      message: "L·ªói server: " + error.message
    });
  }
});
const getOrders = asyncHandler(async (req, res) => {
  try {
    let query = {};
    const userRole = req.user.role;
    const userId = req.user._id;

    // X·ª≠ l√Ω ph√¢n quy·ªÅn
    switch (userRole) {
      case 'user':
        query.userId = userId;
        break;

      case 'staff':
        // query.status = { $in: ['pending', 'processing', 'delivering', 'completed'] };
        break;

      case 'admin':
        // Kh√¥ng th√™m ƒëi·ªÅu ki·ªán
        break;

      default:
        return res.status(403).json({
          success: false,
          message: "Truy c·∫≠p b·ªã t·ª´ ch·ªëi"
        });
    }

    // Th√™m kh·∫£ nƒÉng l·ªçc theo tr·∫°ng th√°i (n·∫øu c·∫ßn)
    if (req.query.status) {
      query.status = req.query.status;
    }

    const orders = await Order.find(query)
      .sort({ createdAt: -1 })
      .lean();

    res.status(200).json({
      success: true,
      data: orders
    });

  } catch (error) {
    res.status(500).json({
      success: false,
      message: "L·ªói server: " + error.message
    });
  }
});
const cancelOrder = asyncHandler(async (req, res) => {
  try {
    const orderId = req.params.id;
    const { _id: userId, role } = req.user;

    // T√¨m ƒë∆°n h√†ng
    const order = await Order.findById(orderId);
    if (!order) {
      return res.status(404).json({
        success: false,
        message: "Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng"
      });
    }

    // Ki·ªÉm tra quy·ªÅn h·ªßy
    const isOwner = order.userId.toString() === userId.toString();
    const isAdminStaff = ['admin', 'staff'].includes(role);

    if (!isOwner && !isAdminStaff) {
      return res.status(403).json({
        success: false,
        message: "Kh√¥ng c√≥ quy·ªÅn th·ª±c hi·ªán thao t√°c n√†y"
      });
    }

    // Ki·ªÉm tra tr·∫°ng th√°i
    if (order.status !== 'pending') {
      return res.status(400).json({
        success: false,
        message: "Ch·ªâ c√≥ th·ªÉ h·ªßy ƒë∆°n h√†ng ·ªü tr·∫°ng th√°i ch·ªù x·ª≠ l√Ω"
      });
    }

    // C·∫≠p nh·∫≠t tr·∫°ng th√°i
    const updatedOrder = await Order.findByIdAndUpdate(
      orderId,
      { status: 'cancelled' },
      { new: true, runValidators: true }
    );

    res.json({
      success: true,
      message: "H·ªßy ƒë∆°n h√†ng th√†nh c√¥ng",
      data: updatedOrder
    });

  } catch (error) {
    res.status(500).json({
      success: false,
      message: "L·ªói server: " + error.message
    });
  }
});
const updateOrderStatus = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { status } = req.body;
  const { role } = req.user;

  // Ch·ªâ admin/staff ƒë∆∞·ª£c c·∫≠p nh·∫≠t
  if (!["admin", "staff", "shipper"].includes(role)) {
    return res.status(403).json({
      success: false,
      message: "Truy c·∫≠p b·ªã t·ª´ ch·ªëi"
    });
  }

  const order = await Order.findById(id);
  if (!order) {
    return res.status(404).json({
      success: false,
      message: "Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng"
    });
  }

  // C·∫≠p nh·∫≠t tr·∫°ng th√°i
  order.status = status;
  await order.save();
  try {
    const user = await User.findById(order.userId);

    if (user && user.fcmToken) {
      const message = {
        notification: {
          title: 'C·∫≠p nh·∫≠t ƒë∆°n h√†ng',
          body: `ƒê∆°n h√†ng #${order._id} ƒë√£ chuy·ªÉn sang tr·∫°ng th√°i ${translateStatus(status)}`
        },
        token: user.fcmToken,
        data: { // D·ªØ li·ªáu t√πy ch·ªânh
          orderId: order._id.toString(),
          newStatus: status,
          click_action: 'FLUTTER_NOTIFICATION_CLICK'
        }
      };
      console.log('üü° G·ª≠i FCM t·ªõi token:', user.fcmToken);

      await admin.messaging().send(message);
      console.log('üü¢ ƒê√£ g·ª≠i FCM th√†nh c√¥ng r√≤i');
    }
  } catch (error) {
    console.error('L·ªói g·ª≠i FCM:', error);
    // Kh√¥ng tr·∫£ v·ªÅ l·ªói cho client v√¨ ƒë√¢y ch·ªâ l√† th√¥ng b√°o ph·ª•
  }

  // X·ª≠ l√Ω n·∫øu tr·∫°ng th√°i l√† rejected
  if (status === "rejected") {
    const user = await User.findOne({ _id: order.userId });
    user.rejectCount += 1;

    if (user.rejectCount >= 3) {
      user.isLocked = true;
    }

    await user.save();
  }

  res.json({
    success: true,
    data: order
  });
});
const unlockUser = asyncHandler(async (req, res) => {
  const { userId } = req.params;

  // Ch·ªâ admin ƒë∆∞·ª£c ph√©p
  if (req.user.role !== "admin") {
    return res.status(403).json({
      success: false,
      message: "Truy c·∫≠p b·ªã t·ª´ ch·ªëi"
    });
  }

  const user = await User.findOne({ _id: userId });
  if (!user) {
    return res.status(404).json({
      success: false,
      message: "Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng"
    });
  }

  // Reset tr·∫°ng th√°i
  user.isLocked = false;
  user.rejectCount = 0;
  await user.save();

  res.json({
    success: true,
    data: user
  });
});
const getTopSoldDishes = asyncHandler(async (req, res) => {
  try {
    let { limit, startDate, endDate } = req.query;
    const parsedLimit = limit ? parseInt(limit) : 60;
    const finalLimit = Number.isInteger(parsedLimit) && parsedLimit > 0 ? parsedLimit : 60;
    if (!startDate || !endDate) {
      const now = new Date();
      endDate = endDate || now.toISOString();
      startDate = startDate || new Date(now.setDate(now.getDate() - 30)).toISOString();
    }
    // Validate date parameters
    if (startDate && isNaN(new Date(startDate))) {
      return res.status(400).json({ success: false, message: "startDate kh√¥ng h·ª£p l·ªá" });
    }
    if (endDate && isNaN(new Date(endDate))) {
      return res.status(400).json({ success: false, message: "endDate kh√¥ng h·ª£p l·ªá" });
    }
    if ((startDate && !endDate) || (!startDate && endDate)) {
      return res.status(400).json({ success: false, message: "C·∫ßn cung c·∫•p c·∫£ startDate v√† endDate" });
    }
    if (startDate && endDate && new Date(startDate) > new Date(endDate)) {
      return res.status(400).json({ success: false, message: "startDate ph·∫£i nh·ªè h∆°n endDate" });
    }

    const pipeline = [
      // B∆∞·ªõc 1: L·ªçc ƒë∆°n h√†ng ƒë√£ ho√†n th√†nh v√† theo th·ªùi gian
      {
        $match: {
          status: "completed",
          ...(startDate && endDate && {
            createdAt: {
              $gte: new Date(startDate),
              $lte: new Date(endDate),
            },
          }),
        },
      },

      // B∆∞·ªõc 2: M·ªü r·ªông m·∫£ng items
      { $unwind: "$items" },

      // B∆∞·ªõc 3: Nh√≥m theo name v√† price ƒë·ªÉ tr√°nh tr√πng l·∫∑p
      {
        $group: {
          _id: {
            name: "$items.name",
            price: "$items.price",
          },
          totalSold: { $sum: "$items.quantity" },
          totalRevenue: { $sum: { $multiply: ["$items.price", "$items.quantity"] } },
          image: { $first: "$items.image" }, // Gi·ªØ l·∫°i ·∫£nh t·ª´ Order
        },
      },
      {
        $lookup: {
          from: "dishes",
          let: { itemName: "$_id.name", itemPrice: { $toDouble: "$_id.price" } },
          pipeline: [
            {
              $match: {
                $expr: {
                  $and: [
                    { $eq: ["$name", "$$itemName"] },
                    { $eq: ["$price", "$$itemPrice"] },
                  ],
                },
              },
            },
            {
              $project: {
                _id: 1,
                category: 1,
                averageRating: 1,  // Th√™m averageRating
                ratingCount: 1,
                // image: 1, // N·∫øu mu·ªën ∆∞u ti√™n ·∫£nh t·ª´ Dish
              },
            },
          ],
          as: "dishInfo",
        },
      },


      // B∆∞·ªõc 5: M·ªü r·ªông v√† ƒë·ªãnh d·∫°ng k·∫øt qu·∫£
      { $unwind: { path: "$dishInfo", preserveNullAndEmptyArrays: true } },
      {
        $project: {
          // _id: 0,
          _id: { $ifNull: ["$dishInfo._id", "N/A"] }, // X·ª≠ l√Ω tr∆∞·ªùng h·ª£p kh√¥ng t√¨m th·∫•y

          name: "$_id.name",
          price: "$_id.price",
          image: { $ifNull: ["$image", "$dishInfo.image"] }, // ∆Øu ti√™n ·∫£nh t·ª´ Order
          // category: { $ifNull: ["$dishInfo.category", "Kh√¥ng x√°c ƒë·ªãnh"] },
          category: { $ifNull: ["$dishInfo.category", "Kh√¥ng x√°c ƒë·ªãnh"] },
          averageRating: { $ifNull: ["$dishInfo.averageRating", 0] },  // Th√™m averageRating, m·∫∑c ƒë·ªãnh 0 n·∫øu kh√¥ng c√≥
          ratingCount: { $ifNull: ["$dishInfo.ratingCount", 0] },      // Th√™m ratingCount, m·∫∑c ƒë·ªãnh 0 n·∫øu kh√¥ng c√≥
          totalSold: 1,
          totalRevenue: 1,
        },
      },

      // B∆∞·ªõc 6: S·∫Øp x·∫øp v√† gi·ªõi h·∫°n k·∫øt qu·∫£
      { $sort: { totalSold: -1 } },
      { $limit: finalLimit },
    ];

    const topDishes = await Order.aggregate(pipeline);

    res.status(200).json({
      success: true,
      count: topDishes.length,
      data: topDishes,
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: "L·ªói server: " + error.message,
    });
  }
});
const acceptOrderForDelivery = asyncHandler(async (req, res) => {
  try {
    const { orderId } = req.params;
    const { phone: staffPhone, name: staffName } = req.user;

    // Ki·ªÉm tra quy·ªÅn (ch·ªâ nh√¢n vi√™n/staff m·ªõi ƒë∆∞·ª£c nh·∫≠n ƒë∆°n)
    if (req.user.role !== 'shipper') {
      return res.status(403).json({
        success: false,
        message: "Ch·ªâ nh√¢n vi√™n ƒë∆∞·ª£c ph√©p nh·∫≠n ƒë∆°n"
      });
    }

    // T√¨m ƒë∆°n h√†ng
    const order = await Order.findById(orderId);
    if (!order) {
      return res.status(404).json({
        success: false,
        message: "Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng"
      });
    }

    // Ki·ªÉm tra tr·∫°ng th√°i ƒë∆°n h√†ng
    if (order.status !== 'delivering') {
      return res.status(400).json({
        success: false,
        message: "Ch·ªâ c√≥ th·ªÉ nh·∫≠n ƒë∆°n h√†ng ·ªü tr·∫°ng th√°i 'ƒëang x·ª≠ l√Ω'"
      });
    }

    // Ki·ªÉm tra n·∫øu ƒë∆°n ƒë√£ c√≥ shipper kh√°c
    if (order.shipper) {
      return res.status(400).json({
        success: false,
        message: "ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c nh√¢n vi√™n kh√°c nh·∫≠n"
      });
    }

    // C·∫≠p nh·∫≠t ƒë∆°n h√†ng

    order.shipper = staffName;
    order.phoneShipper = staffPhone // ho·∫∑c c√≥ th·ªÉ l∆∞u staffId n·∫øu c·∫ßn
    await order.save();

    res.status(200).json({
      success: true,
      message: "Nh·∫≠n ƒë∆°n h√†ng th√†nh c√¥ng",
      data: order
    });

  } catch (error) {
    res.status(500).json({
      success: false,
      message: "L·ªói server: " + error.message
    });
  }
});
const getPendingDeliveryOrders = asyncHandler(async (req, res) => {
  try {
    // Ch·ªâ nh√¢n vi√™n ƒë∆∞·ª£c ph√©p
    if (req.user.role !== 'shipper') {
      return res.status(403).json({
        success: false,
        message: "Truy c·∫≠p b·ªã t·ª´ ch·ªëi"
      });
    }

    const orders = await Order.find({
      status: { $regex: /^delivering$/i }, // Kh·ªõp kh√¥ng ph√¢n bi·ªát ch·ªØ hoa/ch·ªØ th∆∞·ªùng
      $or: [
        { shipper: { $exists: false } },
        { shipper: null }
      ]
    }).sort({ createdAt: 1 });

    res.status(200).json({
      success: true,
      count: orders.length,
      data: orders
    });

  } catch (error) {
    res.status(500).json({
      success: false,
      message: "L·ªói server: " + error.message
    });
  }
});
const getAcceptedDeliveryOrders = asyncHandler(async (req, res) => {
  try {
    // Ch·ªâ nh√¢n vi√™n m·ªõi ƒë∆∞·ª£c ph√©p
    if (req.user.role !== 'shipper') {
      return res.status(403).json({
        success: false,
        message: "Truy c·∫≠p b·ªã t·ª´ ch·ªëi"
      });
    }

    const staffName = req.user.name; // ho·∫∑c req.user._id n·∫øu anh l∆∞u id shipper thay v√¨ t√™n

    const orders = await Order.find({
      status: 'delivering',
      shipper: staffName,  // ho·∫∑c { $exists: true } n·∫øu mu·ªën t·∫•t c·∫£ ƒë∆°n ƒë√£ nh·∫≠n, ho·∫∑c l·ªçc theo staffName n·∫øu m·ªói nh√¢n vi√™n ch·ªâ xem ƒë∆°n m√¨nh nh·∫≠n
    }).sort({ createdAt: -1 }); // M·ªõi nh·∫≠n tr∆∞·ªõc

    res.status(200).json({
      success: true,
      count: orders.length,
      data: orders,
    });

  } catch (error) {
    res.status(500).json({
      success: false,
      message: "L·ªói server: " + error.message,
    });
  }
});

const createPayment = (req, res) => {

  if (!req.query.amount) {
    return res.status(200).json({
      massege: 'Oh noooo',
    })
  }
  process.env.TZ = 'Asia/Ho_Chi_Minh';

  let date = new Date();
  let createDate = moment(date).format('YYYYMMDDHHmmss');

  let ipAddr = req.headers['x-forwarded-for'] ||
    req.connection.remoteAddress ||
    req.socket.remoteAddress ||
    req.connection.socket.remoteAddress;


  let tmnCode = "2F6F1CIB"
  let secretKey = "2M45F7AS2SP46SE6OI7PIFCEDLS9R36T"
  let vnpUrl = "https://sandbox.vnpayment.vn/paymentv2/vpcpay.html"
  let returnUrl = "https://next-shop-gules.vercel.app/query-payment"
  let orderId = createDate
  let amount = req.query.amount
  let bankCode = "NCB"

  let locale = "vn";
  let currCode = 'VND';
  let vnp_Params = {};
  vnp_Params['vnp_Version'] = '2.1.0';
  vnp_Params['vnp_Command'] = 'pay';
  vnp_Params['vnp_TmnCode'] = tmnCode;
  vnp_Params['vnp_Locale'] = locale;
  vnp_Params['vnp_CurrCode'] = currCode;
  vnp_Params['vnp_TxnRef'] = orderId;
  vnp_Params['vnp_OrderInfo'] = 'Thanh toan cho ma GD:' + orderId;
  vnp_Params['vnp_OrderType'] = 'other';
  vnp_Params['vnp_Amount'] = amount * 100;
  vnp_Params['vnp_ReturnUrl'] = returnUrl;
  vnp_Params['vnp_IpAddr'] = ipAddr;
  vnp_Params['vnp_CreateDate'] = createDate;
  if (bankCode !== null && bankCode !== '') {
    vnp_Params['vnp_BankCode'] = bankCode;
  }

  vnp_Params = sortObject(vnp_Params);


  let signData = querystring.stringify(vnp_Params, { encode: false });
  let hmac = crypto.createHmac("sha512", secretKey);
  let signed = hmac.update(new Buffer(signData, 'utf-8')).digest("hex");
  vnp_Params['vnp_SecureHash'] = signed;
  vnpUrl += '?' + querystring.stringify(vnp_Params, { encode: false });

  return res.status(200).json({
    massege: 'OK',
    data: { vnpUrl, orderId, createDate }
  })
}

function sortObject(obj) {
  let sorted = {};
  let str = [];
  let key;
  for (key in obj) {
    if (obj.hasOwnProperty(key)) {
      str.push(encodeURIComponent(key));
    }
  }
  str.sort();
  for (key = 0; key < str.length; key++) {
    sorted[str[key]] = encodeURIComponent(obj[str[key]]).replace(/%20/g, "+");
  }
  return sorted;
}
function translateStatus(status) {
  const statusMap = {
    'pending': 'ch·ªù x·ª≠ l√Ω',
    'processing': 'ch·ªù l√†m m√≥n',
    'delivering': 'giao h√†ng',
    'completed': 'ƒë√£ ho√†n th√†nh',
    'cancelled': 'ƒë√£ h·ªßy',
    'rejected': 'ƒë√£ t·ª´ ch·ªëi'
  };
  return statusMap[status] || status;
}


module.exports = { createOrder, getOrders, cancelOrder, updateOrderStatus, unlockUser, getTopSoldDishes, acceptOrderForDelivery, getPendingDeliveryOrders, getAcceptedDeliveryOrders, createPayment };
